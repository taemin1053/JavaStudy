package extends1.overriding;

/* extends1/ ex3에서
* Car의 move() 메서드를 ElectricCar에서 오버라이딩 했다
* 오버라이딩과 메모리 구조
* 1. electricCar.move()를 호출
* 2.호출한 electricCar의 타입은 ElectricCar이다. 따라서 인스턴스 내부의 ElectricCar타입에서 시작한
* 3.ElectricCar타입에 move() 메서드가 있다. 해당 메서드를 실행 -> 이때 실행할 메서드를 이미 찾았으므로 부모 타입을 찾지 않는다.
*
* 오버로딩(Overloading)과 오버라이딩(Overriding)
* 메서드 오버로딩: 메서드 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩이라 한다.
* 오버로딩은 직역하면 과적인데, 과하게 물건을 담았다는 뜻으로 같은 이름의 메서드를 여러개 정의했다고 이해하면된다.
*
* 메서드 오버라이딩: 메서드 오버라이딩은 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정을 의미한다. 따라서 상속 관계에서 사용한다.
* 부모의 기능을 자식이 다시 정의하는 것이다. 오버라이딩을 단순히 해석하면 무언가를 넘어서 타는 것을 의미.-
* > 자식의 새로운 기능이 부모의 기존 기능을 넘어 타서 기존 기능을 새로운 기능으로 덮어버린다. 즉 한국말로 재정의라고 한다.
*
* 메서드 오버라이딩 조건
* 메서드 이름: 메서드 이름이 같아야한다.
* 메서드 매개변수(파라미터): 매개변수(파라미터 타입),순서, 개수가 같아야한다.
* 반환 타입: 반환 타입이 같아야한다.
* 접근 제어자: 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다 예를 들어 상위 클래스의 메서드가 protect로 선언되어 있으면
* 하위클래스는 public, protect는 가능하지만 private, default 는 안된다
* 예외: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws 선언할 수 없다. 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외 선언은 가능
* static, final, private 키워드가 붙은 메서드는 오버라이딩 될 수 없다
* staic은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다. -> 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 됌
* 생성자 오버라이딩: 생성자는 오버라이딩 할 수 없다
*
* 복습
  +: public
  #: protected
  ~: default
  -: private
접근 제어자를 잠시 복습해보자.
**접근 제어자의 종류**
`private` : 모든 외부 호출을 막는다.
`default` (package-private): 같은 패키지안에서 호출은 허용한다.
`protected` : 같은 패키지안에서 호출은 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다.
`public` : 모든 외부 호출을 허용한다.
순서대로 `private` 이 가장 많이 차단하고, `public` 이 가장 많이 허용한다.
`private -> default -> protected -> public`*/